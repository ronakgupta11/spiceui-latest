import { useWindow } from '@salt-ds/window';
import { useState, useRef, useCallback, useEffect } from 'react';
import { getClickedPosition, getKeyboardValue } from './utils.js';

const useSliderThumb = ({
  decimalPlaces,
  handleInputChange,
  inputRef,
  marks,
  min = 0,
  max = 10,
  step = 1,
  onChange,
  onChangeEnd,
  restrictToMarks,
  setValue,
  stepMultiplier,
  value
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const lastValueRef = useRef(value);
  const sliderRef = useRef(null);
  const targetWindow = useWindow();
  const handlePointerMove = useCallback(
    (event) => {
      if (!sliderRef.current) return;
      const newValue = getClickedPosition(
        sliderRef,
        event.clientX,
        max,
        min,
        step,
        decimalPlaces,
        marks,
        restrictToMarks
      );
      if (newValue === void 0 || lastValueRef.current === newValue) {
        return;
      }
      lastValueRef.current = newValue;
      setValue(newValue);
      onChange == null ? void 0 : onChange(event, newValue);
    },
    [decimalPlaces, marks, max, min, onChange, setValue, restrictToMarks, step]
  );
  const handlePointerUp = useCallback(
    (event) => {
      setIsDragging(false);
      setIsFocusVisible(false);
      onChangeEnd == null ? void 0 : onChangeEnd(event, lastValueRef.current);
    },
    [onChangeEnd]
  );
  useEffect(() => {
    if (isDragging) {
      targetWindow == null ? void 0 : targetWindow.addEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.addEventListener("pointerup", handlePointerUp);
    } else {
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointerup", handlePointerUp);
    }
    return () => {
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointerup", handlePointerUp);
    };
  }, [handlePointerMove, handlePointerUp, isDragging, targetWindow]);
  const handlePointerDownOnThumb = useCallback(
    (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (inputRef.current) inputRef.current.focus();
      setIsDragging(true);
      setIsFocusVisible(false);
    },
    [inputRef]
  );
  const handlePointerDownOnTrack = useCallback(
    (event) => {
      event.preventDefault();
      if (inputRef.current) inputRef.current.focus();
      setIsDragging(true);
      setIsFocusVisible(false);
      const newValue = getClickedPosition(
        sliderRef,
        event.clientX,
        max,
        min,
        step,
        decimalPlaces,
        marks,
        restrictToMarks
      );
      if (newValue === void 0 || lastValueRef.current === newValue) {
        return;
      }
      lastValueRef.current = newValue;
      setValue(newValue);
      onChange == null ? void 0 : onChange(event.nativeEvent, newValue);
    },
    [
      decimalPlaces,
      inputRef,
      marks,
      max,
      min,
      onChange,
      restrictToMarks,
      setValue,
      step
    ]
  );
  const handleKeydownOnThumb = useCallback(
    (event) => {
      const newValue = getKeyboardValue(
        event,
        value,
        step,
        stepMultiplier,
        max,
        min,
        restrictToMarks,
        marks
      );
      if (newValue === void 0 || lastValueRef.current === newValue) {
        return;
      }
      setIsFocusVisible(true);
      lastValueRef.current = newValue;
      handleInputChange({
        target: { value: newValue.toString() }
      });
    },
    [
      value,
      step,
      stepMultiplier,
      max,
      min,
      restrictToMarks,
      marks,
      handleInputChange
    ]
  );
  const handleFocus = () => setIsFocusVisible(true);
  const handleBlur = () => setIsFocusVisible(false);
  return {
    handleBlur,
    handleFocus,
    handleKeydownOnThumb,
    handlePointerDownOnThumb,
    handlePointerDownOnTrack,
    isDragging,
    isFocusVisible,
    sliderRef
  };
};

export { useSliderThumb };
//# sourceMappingURL=useSliderThumb.js.map
