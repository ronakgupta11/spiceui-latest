'use strict';

var jsxRuntime = require('react/jsx-runtime');
var clsx = require('clsx');
var React = require('react');
require('../form-field-context/FormFieldContext.js');
var useFormFieldProps = require('../form-field-context/useFormFieldProps.js');
var useControlled = require('../utils/useControlled.js');
require('../utils/useFloatingUI/useFloatingUI.js');
require('../utils/useId.js');
require('../salt-provider/SaltProvider.js');
require('../viewport/ViewportProvider.js');
var SliderThumb = require('./internal/SliderThumb.js');
var SliderTrack = require('./internal/SliderTrack.js');
var useSliderThumb = require('./internal/useSliderThumb.js');
var utils = require('./internal/utils.js');

const Slider = React.forwardRef(function Slider2({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  "aria-valuetext": ariaValueText,
  accessibleMaxText,
  accessibleMinText,
  decimalPlaces = 2,
  disabled: disabledProp = false,
  format,
  marks,
  min = 0,
  minLabel,
  max = 100,
  maxLabel,
  onChange,
  onChangeEnd,
  restrictToMarks = false,
  showTooltip = true,
  step = 1,
  stepMultiplier = 2,
  value: valueProp,
  defaultValue = min + (max - min) / 2,
  ...rest
}, ref) {
  const [valueState, setValue] = useControlled.useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Slider",
    state: "value"
  });
  const {
    a11yProps: { "aria-labelledby": formFieldLabelledBy } = {},
    disabled: formFieldDisabled
  } = useFormFieldProps.useFormFieldProps();
  const disabled = formFieldDisabled || disabledProp;
  const inputRef = React.useRef(null);
  const value = utils.clamp(
    valueState,
    max,
    min,
    step,
    decimalPlaces,
    marks,
    restrictToMarks
  );
  const progressPercentage = utils.calculatePercentage(utils.toFloat(value), max, min);
  const lastValueRef = React.useRef(value);
  const handleInputChange = (event) => {
    const parsedValue = utils.toFloat(event.target.value);
    if (parsedValue !== lastValueRef.current) {
      setValue(parsedValue);
      onChange == null ? void 0 : onChange(event.nativeEvent, parsedValue);
      onChangeEnd == null ? void 0 : onChangeEnd(event.nativeEvent, parsedValue);
      lastValueRef.current = parsedValue;
    }
  };
  const {
    handleBlur,
    handleFocus,
    handleKeydownOnThumb,
    handlePointerDownOnThumb,
    handlePointerDownOnTrack,
    isDragging,
    isFocusVisible,
    sliderRef
  } = useSliderThumb.useSliderThumb({
    decimalPlaces,
    handleInputChange,
    inputRef,
    marks,
    min,
    max,
    step,
    value,
    onChange,
    onChangeEnd,
    restrictToMarks,
    setValue,
    stepMultiplier
  });
  return /* @__PURE__ */ jsxRuntime.jsx(
    SliderTrack.SliderTrack,
    {
      disabled,
      format,
      handlePointerDown: handlePointerDownOnTrack,
      isDragging,
      min,
      minLabel,
      max,
      maxLabel,
      marks,
      progressPercentage,
      ref,
      sliderRef,
      ...rest,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        SliderThumb.SliderThumb,
        {
          "aria-label": ariaLabel,
          "aria-labelledby": clsx.clsx(formFieldLabelledBy, ariaLabelledBy) || void 0,
          "aria-valuemax": max,
          "aria-valuemin": min,
          "aria-valuetext": ariaValueText,
          accessibleMaxText,
          accessibleMinText,
          disabled,
          format,
          onBlur: handleBlur,
          onFocus: handleFocus,
          handleInputChange,
          handlePointerDown: handlePointerDownOnThumb,
          handleKeydownOnThumb,
          inputRef,
          isFocusVisible,
          min,
          minLabel,
          max,
          maxLabel,
          offsetPercentage: `${progressPercentage}%`,
          restrictToMarks,
          sliderValue: value,
          showTooltip,
          step,
          stepMultiplier,
          trackDragging: isDragging
        }
      )
    }
  );
});

exports.Slider = Slider;
//# sourceMappingURL=Slider.js.map
