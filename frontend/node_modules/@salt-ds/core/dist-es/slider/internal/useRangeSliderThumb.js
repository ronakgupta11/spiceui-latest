import { useWindow } from '@salt-ds/window';
import { useState, useRef, useCallback, useEffect } from 'react';
import { getClickedPosition, getKeyboardValue } from './utils.js';

const useRangeSliderThumb = ({
  decimalPlaces,
  handleInputChange,
  inputRefs,
  marks,
  min = 0,
  max = 10,
  step = 1,
  onChange,
  onChangeEnd,
  restrictToMarks,
  setValue,
  stepMultiplier,
  value
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const [thumbIndexState, setIsThumbIndex] = useState(0);
  const lastValueRef = useRef(value);
  const sliderRef = useRef(null);
  const targetWindow = useWindow();
  const preventThumbOverlap = useCallback(
    (currentValue, value2, thumbIndex) => {
      const values = [...value2];
      if (thumbIndex === 0 && currentValue >= values[1]) {
        values[0] = values[1];
      } else if (thumbIndex === 1 && currentValue <= values[0]) {
        values[1] = values[0];
      } else {
        values[thumbIndex] = currentValue;
      }
      return values;
    },
    []
  );
  const handlePointerMove = useCallback(
    (event) => {
      if (!sliderRef.current) return;
      const newValue = getClickedPosition(
        sliderRef,
        event.clientX,
        max,
        min,
        step,
        decimalPlaces,
        marks,
        restrictToMarks
      );
      if (newValue === void 0) return;
      const newValues = preventThumbOverlap(
        newValue,
        value,
        thumbIndexState
      );
      if (newValues[0] !== lastValueRef.current[0] || newValues[1] !== lastValueRef.current[1]) {
        lastValueRef.current = newValues;
        setValue(newValues);
        onChange == null ? void 0 : onChange(event, newValues);
      }
    },
    [
      decimalPlaces,
      marks,
      max,
      min,
      step,
      preventThumbOverlap,
      restrictToMarks,
      value,
      thumbIndexState,
      setValue,
      onChange
    ]
  );
  const handlePointerUp = useCallback(
    (event) => {
      setIsDragging(false);
      setIsFocusVisible(false);
      onChangeEnd == null ? void 0 : onChangeEnd(event, lastValueRef.current);
    },
    [onChangeEnd]
  );
  useEffect(() => {
    if (isDragging) {
      targetWindow == null ? void 0 : targetWindow.addEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.addEventListener("pointerup", handlePointerUp);
    } else {
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointerup", handlePointerUp);
    }
    return () => {
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointermove", handlePointerMove);
      targetWindow == null ? void 0 : targetWindow.removeEventListener("pointerup", handlePointerUp);
    };
  }, [handlePointerMove, handlePointerUp, isDragging, targetWindow]);
  const handlePointerDownOnThumb = useCallback(
    (event, thumbIndex) => {
      var _a;
      event.preventDefault();
      event.stopPropagation();
      (_a = inputRefs[thumbIndex].current) == null ? void 0 : _a.focus();
      setIsDragging(true);
      setIsFocusVisible(false);
      if (thumbIndex !== void 0) {
        setIsThumbIndex(thumbIndex);
      }
    },
    [inputRefs]
  );
  const handlePointerDownOnTrack = useCallback(
    (event) => {
      var _a;
      event.preventDefault();
      setIsDragging(true);
      const newValue = getClickedPosition(
        sliderRef,
        event.clientX,
        max,
        min,
        step,
        decimalPlaces,
        marks,
        restrictToMarks
      );
      let closestThumbIndex = 0;
      if (newValue === void 0) return;
      const newValues = [...value];
      const distanceToThumb0 = Math.abs(newValue - newValues[0]);
      const distanceToThumb1 = Math.abs(newValue - newValues[1]);
      if (distanceToThumb0 > distanceToThumb1) {
        newValues[1] = newValue;
        closestThumbIndex = 1;
      } else if (distanceToThumb0 < distanceToThumb1) {
        newValues[0] = newValue;
        closestThumbIndex = 0;
      } else {
        if (newValue < newValues[0]) {
          newValues[0] = newValue;
          closestThumbIndex = 0;
        } else if (newValue > newValues[1]) {
          newValues[1] = newValue;
          closestThumbIndex = 1;
        } else {
          newValues[0] = newValue;
          closestThumbIndex = 0;
        }
      }
      setIsThumbIndex(closestThumbIndex);
      (_a = inputRefs[closestThumbIndex].current) == null ? void 0 : _a.focus();
      setIsFocusVisible(false);
      if (newValues[0] !== lastValueRef.current[0] || newValues[1] !== lastValueRef.current[1]) {
        lastValueRef.current = newValues;
        setValue(newValues);
        onChange == null ? void 0 : onChange(event.nativeEvent, newValues);
      }
    },
    [
      decimalPlaces,
      marks,
      value,
      max,
      min,
      inputRefs,
      onChange,
      restrictToMarks,
      setValue,
      step
    ]
  );
  const handleKeydownOnThumb = useCallback(
    (event, thumbIndex) => {
      const newValue = getKeyboardValue(
        event,
        value[thumbIndex],
        step,
        stepMultiplier,
        max,
        min,
        restrictToMarks,
        marks
      );
      if (newValue === void 0 || newValue === lastValueRef.current[thumbIndex]) {
        return;
      }
      setIsFocusVisible(true);
      lastValueRef.current[thumbIndex] = newValue;
      handleInputChange(
        {
          target: { value: newValue.toString() }
        },
        thumbIndex
      );
    },
    [
      value,
      step,
      stepMultiplier,
      max,
      min,
      restrictToMarks,
      marks,
      handleInputChange
    ]
  );
  const handleFocus = (thumbIndex) => {
    setIsThumbIndex(thumbIndex);
    setIsFocusVisible(true);
  };
  const handleBlur = (thumbIndex) => {
    setIsThumbIndex(thumbIndex);
    setIsFocusVisible(false);
  };
  return {
    handleBlur,
    handleFocus,
    handleKeydownOnThumb,
    handlePointerDownOnThumb,
    handlePointerDownOnTrack,
    isDragging,
    isFocusVisible,
    preventThumbOverlap,
    sliderRef,
    thumbIndexState
  };
};

export { useRangeSliderThumb };
//# sourceMappingURL=useRangeSliderThumb.js.map
