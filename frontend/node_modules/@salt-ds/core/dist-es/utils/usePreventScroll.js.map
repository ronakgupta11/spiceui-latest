{"version":3,"file":"usePreventScroll.js","sources":["../src/utils/usePreventScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Taken from https://github.com/adobe/react-spectrum/blob/cc08a8dbc95d3648eee47bc9b8e0ed48448e0da2/packages/%40react-aria/overlays/src/usePreventScroll.ts#L44 but refactored.\n * This hook currently doesn't use `useWindow` because in a desktop environment the main window is only the window they typically want locked.\n * If we need to in the future we can add an option to specify which window should be affected.\n */\n\nimport { createChainedFunction } from \"./createChainedFunction\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean;\n}\n\nconst visualViewport = typeof document !== \"undefined\" && window.visualViewport;\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  \"checkbox\",\n  \"radio\",\n  \"range\",\n  \"color\",\n  \"file\",\n  \"image\",\n  \"button\",\n  \"submit\",\n  \"reset\",\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore: () => void;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  const { isDisabled } = options;\n\n  useIsomorphicLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return createChainedFunction(\n    setStyle(\n      document.documentElement,\n      \"paddingRight\",\n      `${window.innerWidth - document.documentElement.clientWidth}px`,\n    ),\n    setStyle(document.documentElement, \"overflow\", \"hidden\"),\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let restoreScrollableStyles: () => void;\n  const onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element, true);\n    if (\n      scrollable === document.documentElement &&\n      scrollable === document.body\n    ) {\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (\n      scrollable instanceof HTMLElement &&\n      window.getComputedStyle(scrollable).overscrollBehavior === \"auto\"\n    ) {\n      restoreScrollableStyles = setStyle(\n        scrollable,\n        \"overscrollBehavior\",\n        \"contain\",\n      );\n    }\n  };\n\n  const onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (\n      !scrollable ||\n      scrollable === document.documentElement ||\n      scrollable === document.body\n    ) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (\n      scrollable.scrollHeight === scrollable.clientHeight &&\n      scrollable.scrollWidth === scrollable.clientWidth\n    ) {\n      e.preventDefault();\n    }\n  };\n\n  const onTouchEnd = () => {\n    if (restoreScrollableStyles) {\n      restoreScrollableStyles();\n    }\n  };\n\n  const onFocus = (e: FocusEvent) => {\n    const target = e.target as HTMLElement;\n    if (willOpenKeyboard(target)) {\n      setupStyles();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view.\n      target.style.transform = \"translateY(-2000px)\";\n      requestAnimationFrame(() => {\n        target.style.transform = \"\";\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener(\n              \"resize\",\n              () => scrollIntoView(target),\n              { once: true },\n            );\n          }\n        }\n      });\n    }\n  };\n\n  let restoreStyles: null | (() => void) = null;\n  const setupStyles = () => {\n    if (restoreStyles) {\n      return;\n    }\n\n    const onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    const scrollX = window.pageXOffset;\n    const scrollY = window.pageYOffset;\n\n    restoreStyles = createChainedFunction(\n      addEvent(window, \"scroll\", onWindowScroll),\n      setStyle(\n        document.documentElement,\n        \"paddingRight\",\n        `${window.innerWidth - document.documentElement.clientWidth}px`,\n      ),\n      setStyle(document.documentElement, \"overflow\", \"hidden\"),\n      setStyle(document.body, \"marginTop\", `-${scrollY}px`),\n      () => {\n        window.scrollTo(scrollX, scrollY);\n      },\n    );\n\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n\n  const removeEvents = createChainedFunction(\n    addEvent(document, \"touchstart\", onTouchStart, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, \"touchmove\", onTouchMove, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, \"touchend\", onTouchEnd, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, \"focus\", onFocus, true),\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles?.();\n    restoreStyles?.();\n    removeEvents();\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  const cur = element.style[style as any];\n  element.style[style as any] = value;\n\n  return () => {\n    element.style[style as any] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: Document | Window,\n  event: K,\n  handler: (this: Document | Window, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  const root = document.scrollingElement || document.documentElement;\n  let nextTarget: Element | null = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    const scrollable = getScrollParent(nextTarget);\n    if (\n      scrollable !== document.documentElement &&\n      scrollable !== document.body &&\n      scrollable !== nextTarget\n    ) {\n      const scrollableTop = scrollable.getBoundingClientRect().top;\n      const targetTop = nextTarget.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + nextTarget.clientHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    nextTarget = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement &&\n      !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n\nfunction isScrollable(\n  node: Element | null,\n  checkForOverflow?: boolean,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  const style = window.getComputedStyle(node);\n  let isScrollable = /(auto|scroll)/.test(\n    style.overflow + style.overflowX + style.overflowY,\n  );\n\n  if (isScrollable && checkForOverflow) {\n    isScrollable =\n      node.scrollHeight !== node.clientHeight ||\n      node.scrollWidth !== node.clientWidth;\n  }\n\n  return isScrollable;\n}\n\nfunction getScrollParent(node: Element, checkForOverflow?: boolean): Element {\n  let scrollableNode: Element | null = node;\n  if (isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n\n  while (scrollableNode && !isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n\n  return (\n    scrollableNode || document.scrollingElement || document.documentElement\n  );\n}\n\nfunction testPlatform(re: RegExp) {\n  return typeof window !== \"undefined\" && window.navigator != null\n    ? re.test(\n        // @ts-expect-error userAgentData is only supported in Chrome 90+\n        window.navigator.userAgentData?.platform || window.navigator.platform,\n      )\n    : false;\n}\n\nfunction cached(fn: () => boolean) {\n  if (process.env.NODE_ENV === \"test\") {\n    return fn;\n  }\n\n  let res: boolean | null = null;\n  return () => {\n    if (res == null) {\n      res = fn();\n    }\n    return res;\n  };\n}\n\nconst isMac = cached(() => testPlatform(/^Mac/i));\n\nconst isIPhone = cached(() => testPlatform(/^iPhone/i));\n\nconst isIPad = cached(\n  () =>\n    testPlatform(/^iPad/i) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1),\n);\n\nconst isIOS = cached(() => isIPhone() || isIPad());\n"],"names":["isScrollable"],"mappings":"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"}