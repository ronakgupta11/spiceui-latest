'use strict';

var createChainedFunction = require('./createChainedFunction.js');
var useIsomorphicLayoutEffect = require('./useIsomorphicLayoutEffect.js');

const visualViewport = typeof document !== "undefined" && window.visualViewport;
const nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let preventScrollCount = 0;
let restore;
function usePreventScroll(options = {}) {
  const { isDisabled } = options;
  useIsomorphicLayoutEffect.useIsomorphicLayoutEffect(() => {
    if (isDisabled) {
      return;
    }
    preventScrollCount++;
    if (preventScrollCount === 1) {
      if (isIOS()) {
        restore = preventScrollMobileSafari();
      } else {
        restore = preventScrollStandard();
      }
    }
    return () => {
      preventScrollCount--;
      if (preventScrollCount === 0) {
        restore();
      }
    };
  }, [isDisabled]);
}
function preventScrollStandard() {
  return createChainedFunction.createChainedFunction(
    setStyle(
      document.documentElement,
      "paddingRight",
      `${window.innerWidth - document.documentElement.clientWidth}px`
    ),
    setStyle(document.documentElement, "overflow", "hidden")
  );
}
function preventScrollMobileSafari() {
  let scrollable;
  let restoreScrollableStyles;
  const onTouchStart = (e) => {
    scrollable = getScrollParent(e.target, true);
    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }
    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === "auto") {
      restoreScrollableStyles = setStyle(
        scrollable,
        "overscrollBehavior",
        "contain"
      );
    }
  };
  const onTouchMove = (e) => {
    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    }
    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {
      e.preventDefault();
    }
  };
  const onTouchEnd = () => {
    if (restoreScrollableStyles) {
      restoreScrollableStyles();
    }
  };
  const onFocus = (e) => {
    const target = e.target;
    if (willOpenKeyboard(target)) {
      setupStyles();
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";
        if (visualViewport) {
          if (visualViewport.height < window.innerHeight) {
            requestAnimationFrame(() => {
              scrollIntoView(target);
            });
          } else {
            visualViewport.addEventListener(
              "resize",
              () => scrollIntoView(target),
              { once: true }
            );
          }
        }
      });
    }
  };
  let restoreStyles = null;
  const setupStyles = () => {
    if (restoreStyles) {
      return;
    }
    const onWindowScroll = () => {
      window.scrollTo(0, 0);
    };
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    restoreStyles = createChainedFunction.createChainedFunction(
      addEvent(window, "scroll", onWindowScroll),
      setStyle(
        document.documentElement,
        "paddingRight",
        `${window.innerWidth - document.documentElement.clientWidth}px`
      ),
      setStyle(document.documentElement, "overflow", "hidden"),
      setStyle(document.body, "marginTop", `-${scrollY}px`),
      () => {
        window.scrollTo(scrollX, scrollY);
      }
    );
    window.scrollTo(0, 0);
  };
  const removeEvents = createChainedFunction.createChainedFunction(
    addEvent(document, "touchstart", onTouchStart, {
      passive: false,
      capture: true
    }),
    addEvent(document, "touchmove", onTouchMove, {
      passive: false,
      capture: true
    }),
    addEvent(document, "touchend", onTouchEnd, {
      passive: false,
      capture: true
    }),
    addEvent(document, "focus", onFocus, true)
  );
  return () => {
    restoreScrollableStyles == null ? void 0 : restoreScrollableStyles();
    restoreStyles == null ? void 0 : restoreStyles();
    removeEvents();
  };
}
function setStyle(element, style, value) {
  const cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
}
function addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function scrollIntoView(target) {
  const root = document.scrollingElement || document.documentElement;
  let nextTarget = target;
  while (nextTarget && nextTarget !== root) {
    const scrollable = getScrollParent(nextTarget);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {
      const scrollableTop = scrollable.getBoundingClientRect().top;
      const targetTop = nextTarget.getBoundingClientRect().top;
      if (targetTop > scrollableTop + nextTarget.clientHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    nextTarget = scrollable.parentElement;
  }
}
function willOpenKeyboard(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}
function isScrollable(node, checkForOverflow) {
  if (!node) {
    return false;
  }
  const style = window.getComputedStyle(node);
  let isScrollable2 = /(auto|scroll)/.test(
    style.overflow + style.overflowX + style.overflowY
  );
  if (isScrollable2 && checkForOverflow) {
    isScrollable2 = node.scrollHeight !== node.clientHeight || node.scrollWidth !== node.clientWidth;
  }
  return isScrollable2;
}
function getScrollParent(node, checkForOverflow) {
  let scrollableNode = node;
  if (isScrollable(scrollableNode, checkForOverflow)) {
    scrollableNode = scrollableNode.parentElement;
  }
  while (scrollableNode && !isScrollable(scrollableNode, checkForOverflow)) {
    scrollableNode = scrollableNode.parentElement;
  }
  return scrollableNode || document.scrollingElement || document.documentElement;
}
function testPlatform(re) {
  var _a;
  return typeof window !== "undefined" && window.navigator != null ? re.test(
    // @ts-expect-error userAgentData is only supported in Chrome 90+
    ((_a = window.navigator.userAgentData) == null ? void 0 : _a.platform) || window.navigator.platform
  ) : false;
}
function cached(fn) {
  if (process.env.NODE_ENV === "test") {
    return fn;
  }
  let res = null;
  return () => {
    if (res == null) {
      res = fn();
    }
    return res;
  };
}
const isMac = cached(() => testPlatform(/^Mac/i));
const isIPhone = cached(() => testPlatform(/^iPhone/i));
const isIPad = cached(
  () => testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1
);
const isIOS = cached(() => isIPhone() || isIPad());

exports.usePreventScroll = usePreventScroll;
//# sourceMappingURL=usePreventScroll.js.map
