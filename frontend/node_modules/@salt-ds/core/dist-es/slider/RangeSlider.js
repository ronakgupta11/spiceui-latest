import { jsxs, jsx } from 'react/jsx-runtime';
import { clsx } from 'clsx';
import { forwardRef, useRef } from 'react';
import '../form-field-context/FormFieldContext.js';
import { useFormFieldProps } from '../form-field-context/useFormFieldProps.js';
import { useControlled } from '../utils/useControlled.js';
import '../utils/useFloatingUI/useFloatingUI.js';
import '../utils/useId.js';
import '../salt-provider/SaltProvider.js';
import '../viewport/ViewportProvider.js';
import { SliderThumb } from './internal/SliderThumb.js';
import { SliderTrack } from './internal/SliderTrack.js';
import { useRangeSliderThumb } from './internal/useRangeSliderThumb.js';
import { clampRange, calculatePercentage, toFloat } from './internal/utils.js';

const RangeSlider = forwardRef(
  function RangeSlider2({
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValueText,
    accessibleMaxText,
    accessibleMinText,
    decimalPlaces = 2,
    disabled: disabledProp = false,
    format,
    marks,
    max = 100,
    min = 0,
    maxLabel,
    minLabel,
    onChange,
    onChangeEnd,
    restrictToMarks = false,
    showTooltip = true,
    step = 1,
    stepMultiplier = 2,
    value: valueProp,
    defaultValue = [min, min + (max - min) / 2],
    ...rest
  }, ref) {
    const [valueState, setValue] = useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "RangeSlider",
      state: "value"
    });
    const lastValueRef = useRef(valueState);
    const {
      a11yProps: { "aria-labelledby": formFieldLabelledBy } = {},
      disabled: formFieldDisabled
    } = useFormFieldProps();
    const disabled = formFieldDisabled || disabledProp;
    const inputRefs = Array.from(
      { length: 2 },
      () => useRef(null)
    );
    const value = clampRange(
      valueState,
      max,
      min,
      step,
      decimalPlaces,
      marks,
      restrictToMarks
    );
    const progressPercentageStart = calculatePercentage(value[0], max, min);
    const progressPercentageEnd = calculatePercentage(value[1], max, min);
    const handleInputChange = (event, thumbIndex) => {
      const parsedValue = toFloat(event.target.value);
      const values = preventThumbOverlap(parsedValue, value, thumbIndex);
      const haveValuesChanged = values[0] !== lastValueRef.current[0] || values[1] !== lastValueRef.current[1];
      if (haveValuesChanged) {
        const values2 = preventThumbOverlap(parsedValue, value, thumbIndex);
        setValue(values2);
        onChange == null ? void 0 : onChange(event.nativeEvent, values2);
        onChangeEnd == null ? void 0 : onChangeEnd(event.nativeEvent, values2);
        lastValueRef.current = values2;
      }
    };
    const {
      handleBlur,
      handleFocus,
      handleKeydownOnThumb,
      handlePointerDownOnThumb,
      handlePointerDownOnTrack,
      isDragging,
      isFocusVisible,
      sliderRef,
      thumbIndexState,
      preventThumbOverlap
    } = useRangeSliderThumb({
      decimalPlaces,
      handleInputChange,
      inputRefs,
      marks,
      min,
      max,
      step,
      value,
      onChange,
      onChangeEnd,
      restrictToMarks,
      setValue,
      stepMultiplier
    });
    const thumbProps = {
      "aria-label": ariaLabel,
      "aria-labelledby": clsx(formFieldLabelledBy, ariaLabelledBy),
      "aria-valuemax": max,
      "aria-valuemin": min,
      "aria-valuetext": ariaValueText,
      accessibleMaxText,
      accessibleMinText,
      disabled,
      format,
      max,
      maxLabel,
      min,
      minLabel,
      restrictToMarks,
      showTooltip,
      step,
      stepMultiplier,
      sliderValue: value
    };
    return /* @__PURE__ */ jsxs(
      SliderTrack,
      {
        disabled,
        format,
        handlePointerDown: handlePointerDownOnTrack,
        isDragging,
        isRange: true,
        marks,
        min,
        minLabel,
        max,
        maxLabel,
        progressPercentageRange: [
          progressPercentageStart,
          progressPercentageEnd
        ],
        ref,
        sliderRef,
        ...rest,
        children: [
          /* @__PURE__ */ jsx(
            SliderThumb,
            {
              index: 0,
              handleInputChange: (event) => handleInputChange(event, 0),
              handlePointerDown: (event) => handlePointerDownOnThumb(event, 0),
              handleKeydownOnThumb: (event) => handleKeydownOnThumb(event, 0),
              offsetPercentage: `${calculatePercentage(value[0], max, min)}%`,
              trackDragging: isDragging && thumbIndexState === 0,
              isFocusVisible: isFocusVisible && thumbIndexState === 0,
              inputRef: inputRefs[0],
              onFocus: () => handleFocus(0),
              onBlur: () => handleBlur(0),
              ...thumbProps
            }
          ),
          /* @__PURE__ */ jsx(
            SliderThumb,
            {
              index: 1,
              handleInputChange: (event) => handleInputChange(event, 1),
              handlePointerDown: (event) => handlePointerDownOnThumb(event, 1),
              handleKeydownOnThumb: (event) => handleKeydownOnThumb(event, 1),
              offsetPercentage: `${calculatePercentage(value[1], max, min)}%`,
              trackDragging: isDragging && thumbIndexState === 1,
              isFocusVisible: isFocusVisible && thumbIndexState === 1,
              inputRef: inputRefs[1],
              onFocus: () => handleFocus(1),
              onBlur: () => handleBlur(1),
              ...thumbProps
            }
          )
        ]
      }
    );
  }
);

export { RangeSlider };
//# sourceMappingURL=RangeSlider.js.map
