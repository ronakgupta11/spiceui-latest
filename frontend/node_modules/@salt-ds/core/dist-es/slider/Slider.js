import { jsx } from 'react/jsx-runtime';
import { clsx } from 'clsx';
import { forwardRef, useRef } from 'react';
import '../form-field-context/FormFieldContext.js';
import { useFormFieldProps } from '../form-field-context/useFormFieldProps.js';
import { useControlled } from '../utils/useControlled.js';
import '../utils/useFloatingUI/useFloatingUI.js';
import '../utils/useId.js';
import '../salt-provider/SaltProvider.js';
import '../viewport/ViewportProvider.js';
import { SliderThumb } from './internal/SliderThumb.js';
import { SliderTrack } from './internal/SliderTrack.js';
import { useSliderThumb } from './internal/useSliderThumb.js';
import { clamp, calculatePercentage, toFloat } from './internal/utils.js';

const Slider = forwardRef(function Slider2({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  "aria-valuetext": ariaValueText,
  accessibleMaxText,
  accessibleMinText,
  decimalPlaces = 2,
  disabled: disabledProp = false,
  format,
  marks,
  min = 0,
  minLabel,
  max = 100,
  maxLabel,
  onChange,
  onChangeEnd,
  restrictToMarks = false,
  showTooltip = true,
  step = 1,
  stepMultiplier = 2,
  value: valueProp,
  defaultValue = min + (max - min) / 2,
  ...rest
}, ref) {
  const [valueState, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Slider",
    state: "value"
  });
  const {
    a11yProps: { "aria-labelledby": formFieldLabelledBy } = {},
    disabled: formFieldDisabled
  } = useFormFieldProps();
  const disabled = formFieldDisabled || disabledProp;
  const inputRef = useRef(null);
  const value = clamp(
    valueState,
    max,
    min,
    step,
    decimalPlaces,
    marks,
    restrictToMarks
  );
  const progressPercentage = calculatePercentage(toFloat(value), max, min);
  const lastValueRef = useRef(value);
  const handleInputChange = (event) => {
    const parsedValue = toFloat(event.target.value);
    if (parsedValue !== lastValueRef.current) {
      setValue(parsedValue);
      onChange == null ? void 0 : onChange(event.nativeEvent, parsedValue);
      onChangeEnd == null ? void 0 : onChangeEnd(event.nativeEvent, parsedValue);
      lastValueRef.current = parsedValue;
    }
  };
  const {
    handleBlur,
    handleFocus,
    handleKeydownOnThumb,
    handlePointerDownOnThumb,
    handlePointerDownOnTrack,
    isDragging,
    isFocusVisible,
    sliderRef
  } = useSliderThumb({
    decimalPlaces,
    handleInputChange,
    inputRef,
    marks,
    min,
    max,
    step,
    value,
    onChange,
    onChangeEnd,
    restrictToMarks,
    setValue,
    stepMultiplier
  });
  return /* @__PURE__ */ jsx(
    SliderTrack,
    {
      disabled,
      format,
      handlePointerDown: handlePointerDownOnTrack,
      isDragging,
      min,
      minLabel,
      max,
      maxLabel,
      marks,
      progressPercentage,
      ref,
      sliderRef,
      ...rest,
      children: /* @__PURE__ */ jsx(
        SliderThumb,
        {
          "aria-label": ariaLabel,
          "aria-labelledby": clsx(formFieldLabelledBy, ariaLabelledBy) || void 0,
          "aria-valuemax": max,
          "aria-valuemin": min,
          "aria-valuetext": ariaValueText,
          accessibleMaxText,
          accessibleMinText,
          disabled,
          format,
          onBlur: handleBlur,
          onFocus: handleFocus,
          handleInputChange,
          handlePointerDown: handlePointerDownOnThumb,
          handleKeydownOnThumb,
          inputRef,
          isFocusVisible,
          min,
          minLabel,
          max,
          maxLabel,
          offsetPercentage: `${progressPercentage}%`,
          restrictToMarks,
          sliderValue: value,
          showTooltip,
          step,
          stepMultiplier,
          trackDragging: isDragging
        }
      )
    }
  );
});

export { Slider };
//# sourceMappingURL=Slider.js.map
