import { jsx } from 'react/jsx-runtime';
import { useState, useContext } from 'react';
import { createContext } from '../utils/createContext.js';
import { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect.js';

const Context = createContext("BreakpointContext", {
  matchedBreakpoints: []
});
function BreakpointProvider(props) {
  const { children, matchedBreakpoints } = props;
  return /* @__PURE__ */ jsx(Context.Provider, { value: { matchedBreakpoints }, children });
}
function useMatchedBreakpoints(breakpoints) {
  const entries = Object.entries(breakpoints).sort(([, a], [, b]) => b - a);
  const queries = entries.map(([, value]) => `(min-width: ${value}px)`);
  const supportsMatchMedia = typeof window !== "undefined" && typeof window.matchMedia === "function";
  const [matchedBreakpoints, setMatchedBreakpoints] = useState(Object.fromEntries(entries.map(([bp]) => [bp, false])));
  useIsomorphicLayoutEffect(() => {
    if (!supportsMatchMedia) {
      return;
    }
    const matchers = queries.map((query, index) => {
      const mq = window.matchMedia(query);
      const bp = entries[index][0];
      return {
        mq,
        handler: () => {
          setMatchedBreakpoints((prev) => {
            return {
              ...prev,
              [bp]: mq.matches
            };
          });
        }
      };
    });
    matchers.forEach(({ mq, handler }) => {
      handler();
      mq.addEventListener("change", handler);
    });
    return () => {
      matchers.forEach(({ mq, handler }) => {
        mq.removeEventListener("change", handler);
      });
    };
  }, [supportsMatchMedia]);
  return Object.keys(matchedBreakpoints).filter(
    (bp) => matchedBreakpoints[bp]
  );
}
function useBreakpoint() {
  const { matchedBreakpoints } = useContext(Context);
  return {
    matchedBreakpoints,
    breakpoint: matchedBreakpoints[0] ?? null
  };
}

export { BreakpointProvider, useBreakpoint, useMatchedBreakpoints };
//# sourceMappingURL=BreakpointProvider.js.map
