'use strict';

var jsxRuntime = require('react/jsx-runtime');
var styles = require('@salt-ds/styles');
var window = require('@salt-ds/window');
var clsx = require('clsx');
var React = require('react');
var makePrefixer = require('../../utils/makePrefixer.js');
require('../../utils/useFloatingUI/useFloatingUI.js');
var useId = require('../../utils/useId.js');
require('../../salt-provider/SaltProvider.js');
require('../../viewport/ViewportProvider.js');
var SliderThumb$1 = require('./SliderThumb.css.js');
var SliderTooltip = require('./SliderTooltip.js');

const withBaseName = makePrefixer.makePrefixer("saltSliderThumb");
const SliderThumb = ({
  "aria-label": ariaLabel,
  "aria-valuetext": ariaValueText,
  "aria-labelledby": ariaLabelledBy,
  accessibleMaxText,
  accessibleMinText,
  disabled,
  format,
  handleInputChange,
  handleKeydownOnThumb,
  handlePointerDown,
  index = 0,
  inputRef,
  isFocusVisible,
  max,
  maxLabel,
  min,
  minLabel,
  offsetPercentage,
  restrictToMarks,
  showTooltip,
  sliderValue,
  step,
  stepMultiplier,
  trackDragging,
  ...rest
}) => {
  {
    const targetWindow = window.useWindow();
    styles.useComponentCssInjection({
      testId: "salt-slider-thumb",
      css: SliderThumb$1,
      window: targetWindow
    });
    const [isTooltipVisible, setIsTooltipVisible] = React.useState(false);
    const id = useId.useId();
    const accessibleTextId = `saltSlider-${id}-${index}`;
    const value = Array.isArray(sliderValue) ? sliderValue[index] : sliderValue;
    const formattedValue = format ? format(value) : value;
    const handleKeyDown = React.useCallback((event) => {
      if (event.key === "Escape") {
        setIsTooltipVisible(false);
      }
    }, []);
    React.useEffect(() => {
      if (showTooltip && isTooltipVisible) {
        targetWindow == null ? void 0 : targetWindow.addEventListener("keydown", handleKeyDown);
      }
      return () => targetWindow == null ? void 0 : targetWindow.removeEventListener("keydown", handleKeyDown);
    }, [handleKeyDown, isTooltipVisible, showTooltip, targetWindow]);
    const handlePointerEnter = () => setIsTooltipVisible(true);
    const handlePointerLeave = () => {
      setTimeout(() => {
        setIsTooltipVisible(false);
      }, 300);
    };
    return /* @__PURE__ */ jsxRuntime.jsxs(
      "div",
      {
        className: clsx.clsx(withBaseName(), {
          [withBaseName("focusVisible")]: isFocusVisible,
          [withBaseName("disabled")]: disabled,
          [withBaseName("dragging")]: trackDragging,
          [withBaseName("secondThumb")]: index === 1
        }),
        "data-testid": "sliderThumb",
        onPointerDown: handlePointerDown,
        style: { left: offsetPercentage },
        ...showTooltip && {
          onPointerEnter: handlePointerEnter,
          onPointerLeave: handlePointerLeave
        },
        children: [
          showTooltip && /* @__PURE__ */ jsxRuntime.jsx(
            SliderTooltip.SliderTooltip,
            {
              value: formattedValue,
              open: (isTooltipVisible || trackDragging || isFocusVisible) && !disabled
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            "input",
            {
              disabled,
              type: "range",
              ref: inputRef,
              className: withBaseName("input"),
              value,
              onChange: handleInputChange,
              onKeyDown: handleKeydownOnThumb,
              "aria-labelledby": ariaLabelledBy,
              "aria-valuenow": value,
              "aria-valuetext": ariaValueText || (format == null ? void 0 : format(value).toString()),
              "aria-label": ariaLabel,
              "aria-describedby": accessibleTextId,
              min,
              max,
              step,
              ...rest
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsxs(
            "span",
            {
              "aria-hidden": "true",
              id: accessibleTextId,
              className: withBaseName("accessibleText"),
              children: [
                Array.isArray(sliderValue) && `${index === 0 ? "leading" : "trailing"}, ${(format == null ? void 0 : format(sliderValue[0])) || sliderValue[0]} to ${(format == null ? void 0 : format(sliderValue[1])) || sliderValue[1]}, `,
                "range",
                " ",
                accessibleMinText ? `${accessibleMinText} ${min}, ` : `minimum ${(format == null ? void 0 : format(min)) || min}, `,
                accessibleMaxText ? `${accessibleMaxText} ${max} ` : `maximum ${(format == null ? void 0 : format(max)) || max}`,
                restrictToMarks ? ", custom increments" : step !== 1 && `, increments of ${step}`
              ]
            }
          )
        ]
      }
    );
  }
};

exports.SliderThumb = SliderThumb;
//# sourceMappingURL=SliderThumb.js.map
