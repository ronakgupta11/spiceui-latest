'use strict';

var jsxRuntime = require('react/jsx-runtime');
var clsx = require('clsx');
var React = require('react');
require('../form-field-context/FormFieldContext.js');
var useFormFieldProps = require('../form-field-context/useFormFieldProps.js');
var useControlled = require('../utils/useControlled.js');
require('../utils/useFloatingUI/useFloatingUI.js');
require('../utils/useId.js');
require('../salt-provider/SaltProvider.js');
require('../viewport/ViewportProvider.js');
var SliderThumb = require('./internal/SliderThumb.js');
var SliderTrack = require('./internal/SliderTrack.js');
var useRangeSliderThumb = require('./internal/useRangeSliderThumb.js');
var utils = require('./internal/utils.js');

const RangeSlider = React.forwardRef(
  function RangeSlider2({
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValueText,
    accessibleMaxText,
    accessibleMinText,
    decimalPlaces = 2,
    disabled: disabledProp = false,
    format,
    marks,
    max = 100,
    min = 0,
    maxLabel,
    minLabel,
    onChange,
    onChangeEnd,
    restrictToMarks = false,
    showTooltip = true,
    step = 1,
    stepMultiplier = 2,
    value: valueProp,
    defaultValue = [min, min + (max - min) / 2],
    ...rest
  }, ref) {
    const [valueState, setValue] = useControlled.useControlled({
      controlled: valueProp,
      default: defaultValue,
      name: "RangeSlider",
      state: "value"
    });
    const lastValueRef = React.useRef(valueState);
    const {
      a11yProps: { "aria-labelledby": formFieldLabelledBy } = {},
      disabled: formFieldDisabled
    } = useFormFieldProps.useFormFieldProps();
    const disabled = formFieldDisabled || disabledProp;
    const inputRefs = Array.from(
      { length: 2 },
      () => React.useRef(null)
    );
    const value = utils.clampRange(
      valueState,
      max,
      min,
      step,
      decimalPlaces,
      marks,
      restrictToMarks
    );
    const progressPercentageStart = utils.calculatePercentage(value[0], max, min);
    const progressPercentageEnd = utils.calculatePercentage(value[1], max, min);
    const handleInputChange = (event, thumbIndex) => {
      const parsedValue = utils.toFloat(event.target.value);
      const values = preventThumbOverlap(parsedValue, value, thumbIndex);
      const haveValuesChanged = values[0] !== lastValueRef.current[0] || values[1] !== lastValueRef.current[1];
      if (haveValuesChanged) {
        const values2 = preventThumbOverlap(parsedValue, value, thumbIndex);
        setValue(values2);
        onChange == null ? void 0 : onChange(event.nativeEvent, values2);
        onChangeEnd == null ? void 0 : onChangeEnd(event.nativeEvent, values2);
        lastValueRef.current = values2;
      }
    };
    const {
      handleBlur,
      handleFocus,
      handleKeydownOnThumb,
      handlePointerDownOnThumb,
      handlePointerDownOnTrack,
      isDragging,
      isFocusVisible,
      sliderRef,
      thumbIndexState,
      preventThumbOverlap
    } = useRangeSliderThumb.useRangeSliderThumb({
      decimalPlaces,
      handleInputChange,
      inputRefs,
      marks,
      min,
      max,
      step,
      value,
      onChange,
      onChangeEnd,
      restrictToMarks,
      setValue,
      stepMultiplier
    });
    const thumbProps = {
      "aria-label": ariaLabel,
      "aria-labelledby": clsx.clsx(formFieldLabelledBy, ariaLabelledBy),
      "aria-valuemax": max,
      "aria-valuemin": min,
      "aria-valuetext": ariaValueText,
      accessibleMaxText,
      accessibleMinText,
      disabled,
      format,
      max,
      maxLabel,
      min,
      minLabel,
      restrictToMarks,
      showTooltip,
      step,
      stepMultiplier,
      sliderValue: value
    };
    return /* @__PURE__ */ jsxRuntime.jsxs(
      SliderTrack.SliderTrack,
      {
        disabled,
        format,
        handlePointerDown: handlePointerDownOnTrack,
        isDragging,
        isRange: true,
        marks,
        min,
        minLabel,
        max,
        maxLabel,
        progressPercentageRange: [
          progressPercentageStart,
          progressPercentageEnd
        ],
        ref,
        sliderRef,
        ...rest,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx(
            SliderThumb.SliderThumb,
            {
              index: 0,
              handleInputChange: (event) => handleInputChange(event, 0),
              handlePointerDown: (event) => handlePointerDownOnThumb(event, 0),
              handleKeydownOnThumb: (event) => handleKeydownOnThumb(event, 0),
              offsetPercentage: `${utils.calculatePercentage(value[0], max, min)}%`,
              trackDragging: isDragging && thumbIndexState === 0,
              isFocusVisible: isFocusVisible && thumbIndexState === 0,
              inputRef: inputRefs[0],
              onFocus: () => handleFocus(0),
              onBlur: () => handleBlur(0),
              ...thumbProps
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            SliderThumb.SliderThumb,
            {
              index: 1,
              handleInputChange: (event) => handleInputChange(event, 1),
              handlePointerDown: (event) => handlePointerDownOnThumb(event, 1),
              handleKeydownOnThumb: (event) => handleKeydownOnThumb(event, 1),
              offsetPercentage: `${utils.calculatePercentage(value[1], max, min)}%`,
              trackDragging: isDragging && thumbIndexState === 1,
              isFocusVisible: isFocusVisible && thumbIndexState === 1,
              inputRef: inputRefs[1],
              onFocus: () => handleFocus(1),
              onBlur: () => handleBlur(1),
              ...thumbProps
            }
          )
        ]
      }
    );
  }
);

exports.RangeSlider = RangeSlider;
//# sourceMappingURL=RangeSlider.js.map
