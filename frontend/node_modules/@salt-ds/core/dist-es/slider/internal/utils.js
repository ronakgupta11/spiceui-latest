const toFloat = (value) => typeof value === "string" ? Number.parseFloat(value) : value;
const calculateMarkPosition = (value, max, min) => {
  if (min === max) {
    return 0;
  }
  const clampedValue = Number.isNaN(toFloat(value)) ? min : Math.min(Math.max(toFloat(value), min), max);
  const markPosition = (clampedValue - min) / (max - min) * 100;
  return Math.round(markPosition * 100) / 100;
};
const calculatePercentage = (value, max, min) => (value - min) / (max - min) * 100;
const clamp = (value, max, min, step, decimalPlaces, marks, restrictToMarks) => {
  if (Number.isNaN(value)) {
    return min;
  }
  const clampedValue = Math.min(Math.max(value, min), max);
  if (restrictToMarks && marks) {
    let closestMark = marks[0].value;
    let smallestDifference = Math.abs(clampedValue - closestMark);
    for (let i = 1; i < marks.length; i++) {
      const currentDifference = Math.abs(clampedValue - marks[i].value);
      if (currentDifference < smallestDifference) {
        smallestDifference = currentDifference;
        closestMark = marks[i].value;
      }
    }
    return closestMark;
  }
  let roundedValue = Math.round(clampedValue / step) * step;
  if (roundedValue > max) {
    roundedValue = max;
  } else if (roundedValue < min) {
    roundedValue = min;
  }
  return Number.parseFloat(roundedValue.toFixed(decimalPlaces));
};
const clampRange = (range, max, min, step, decimalPlaces, marks, restrictToMarks) => {
  let [start, end] = range;
  if (Number.isNaN(start)) {
    start = min;
  }
  if (Number.isNaN(end)) {
    end = max;
  }
  if (start > end) {
    [start, end] = [end, start];
  }
  start = clamp(start, max, min, step, decimalPlaces, marks, restrictToMarks);
  end = clamp(end, max, min, step, decimalPlaces, marks, restrictToMarks);
  return [start, end];
};
const getClickedPosition = (sliderRef, clientX, max, min, step, decimalPlaces, marks, restrictToMarks) => {
  if (!sliderRef.current) return;
  const sliderRect = sliderRef.current.getBoundingClientRect();
  const rawValue = (clientX - sliderRect.left) / sliderRect.width * (max - min) + min;
  const steppedValue = Math.round(rawValue / step) * step;
  return clamp(
    steppedValue,
    max,
    min,
    step,
    decimalPlaces,
    marks,
    restrictToMarks
  );
};
const getKeyboardValue = (event, value, step, stepMultiplier, max, min, restrictToMarks, marks) => {
  let newValue = value;
  if (restrictToMarks && marks && marks.length >= 1) {
    const currentIndex = marks.findIndex((mark) => mark.value === value);
    switch (event.key) {
      case "ArrowUp":
      case "ArrowRight":
      case "PageUp":
        if (currentIndex < marks.length - 1) {
          newValue = marks[currentIndex + 1].value;
        }
        break;
      case "ArrowDown":
      case "ArrowLeft":
      case "PageDown":
        if (currentIndex > 0) {
          newValue = marks[currentIndex - 1].value;
        }
        break;
      default:
        return newValue;
    }
  } else {
    switch (event.key) {
      case "ArrowUp":
      case "ArrowRight":
        newValue = Math.min(value + step, max);
        break;
      case "ArrowDown":
      case "ArrowLeft":
        newValue = Math.max(value - step, min);
        break;
      case "Home":
        newValue = min;
        break;
      case "End":
        newValue = max;
        break;
      case "PageUp":
        newValue = Math.min(value + step * stepMultiplier, max);
        break;
      case "PageDown":
        newValue = Math.max(value - step * stepMultiplier, min);
        break;
      default:
        return newValue;
    }
  }
  event.preventDefault();
  return newValue;
};

export { calculateMarkPosition, calculatePercentage, clamp, clampRange, getClickedPosition, getKeyboardValue, toFloat };
//# sourceMappingURL=utils.js.map
